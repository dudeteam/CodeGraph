<!--
Copyright (c) 2015 DudeTeam. All rights reserved.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/classes/iron-flex-layout.html">
<link rel="import" href="../iron-a11y-keys-behavior/iron-a11y-keys-behavior.html">
<link rel="import" href="../dude-popup/dude-popup.html">
<link rel="import" href="../dude-hierarchy/dude-hierarchy.html">
<script src="../lodash/lodash.min.js"></script>
<script src="../d3/d3.min.js"></script>
<script src="../eventEmitter/EventEmitter.min.js"></script>
<script src="dude-graph.js"></script>
<!--
`dude-graph-editor` is a Polymer element which creates a dudeGraph SVG renderer.

@group dude-graph
@element dude-graph-editor
@demo demo/index.html
-->
<dom-module id="dude-graph-editor">
    <style>
        /**
         * SVG viewport
         */
        #svg {
            background: var(--dude-primary-background-color);
        }

        /**
         * Typography
         */
        ::content text {
            fill: var(--dude-content-text-color);
            font-family: var(--dude-primary-text-font);
        }

        ::content .dude-graph-title {
            fill: var(--dude-title-text-color);
            font-weight: bold;
        }

        /**
         * Select brush
         */
        ::content .dude-graph-select {
            fill: hsla(0, 0%, 80%, 0.1);
            stroke: hsla(0, 0%, 80%, 0.2);
        }

        /**
         * Blocks
         */
        ::content .dude-graph-block > rect {
            @apply(--dude-graph-block);
        }

        ::content .dude-graph-block:hover > rect {
            @apply(--dude-graph-block-hover);
        }

        ::content .dude-graph-block.dude-graph-selected > rect {
            @apply(--dude-graph-block-selected);
        }

        /**
         * Groups
         */
        ::content .dude-graph-group > rect {
            @apply(--dude-graph-group);
        }

        ::content .dude-graph-group:hover > rect {
            @apply(--dude-graph-group-hover)
        }

        ::content .dude-graph-group.dude-graph-selected > rect,
        ::content .dude-graph-group.dude-graph-active > rect {
            @apply(--dude-graph-group-selected);
        }

        /**
         * Connections
         */
        ::content .dude-graph-connection {
            stroke-width: 2px;
            fill: transparent;
        }

        /**
         * Cursors block, groups and points
         */
        ::content .dude-graph-block,
        ::content .dude-graph-group {
            cursor: move;
        }

        ::content .dude-graph-point,
        ::content .dude-graph-point {
            cursor: pointer;
        }
    </style>
    <template>
        <div class="layout flex horizontal">
            <svg id="svg" class="flex"></svg>
            <dude-popup id="autocompletePopup">
                <dude-hierarchy
                        id="autocomplete"
                        placeholder="Search block..."
                        items="[[ _autocompleteModels ]]"
                        on-dude-hierarchy-item-submit="_autocomplete"
                        on-dude-hierarchy-blur="_closeAutocomplete">
                </dude-hierarchy>
            </dude-popup>
        </div>
    </template>
</dom-module>
<script>
    var DudeGraphEditor = Polymer({
        is: "dude-graph-editor",
        behaviors: [Polymer.IronA11yKeysBehavior],
        properties: {
            /**
             *
             */
            "graph": {
                "type": dudeGraph.Graph,
                "value": null
            },

            /**
             *
             */
            "renderer": {
                "type": dudeGraph.Renderer,
                "value": null
            },

            /**
             *
             */
            "resources": {
                "type": Object,
                "value": null
            },

            /**
             *
             */
            "models": {
                "type": Array,
                "value": []
            },

            /**
             *
             */
            "loader": {
                "type": dudeGraph.GraphLoader,
                "value": null
            },

            /**
             *
             */
            "saver": {
                "type": dudeGraph.GraphSaver,
                "value": null
            }
        },

        /**
         * @type {dudeGraph.RenderConnection}
         */
        _autocompleteRenderConnection: null,

        /**
         * @type {Array<Object>}
         */
        _autocompleteModels: [],

        /**
         *
         * @param {Array<>} [blockTypes=defaultBlockTypes]
         * @param {Array<>} [pointTypes=defaultPointTypes]
         * @param {Array<>} [renderBlockTypes=defaultRenderBlockTypes]
         */
        start: function (blockTypes, pointTypes, renderBlockTypes) {
            var editor = this;
            this.set("graph", new dudeGraph.Graph());
            this.set("renderer", new dudeGraph.Renderer());
            this.set("loader", new dudeGraph.GraphLoader());
            this.set("saver", new dudeGraph.GraphSaver());
            this.get("renderer").initialize(this.get("graph"), this.$["svg"]);
            _.forEach(blockTypes || defaultBlockTypes, function (blockType) {
                this.get("loader").registerBlockType(blockType.block, blockType.type);
            }.bind(this));
            _.forEach(pointTypes || defaultPointTypes, function (pointType) {
                this.get("loader").registerPointType(pointType.point, pointType.type);
            }.bind(this));
            _.forEach(renderBlockTypes || defaultRenderBlockTypes, function (renderBlockType) {
                this.get("renderer").registerRenderBlock(renderBlockType.renderBlock, renderBlockType.type);
            }.bind(this));
            this.get("renderer").on("drop-connection", function (renderConnection, __, position) {
                var realRenderPoint = renderConnection.realRenderPoint;
                var autocompleteModels = editor.queryModels(realRenderPoint.point.cgValueType, realRenderPoint.point.isOutput);
                editor.set("_autocompleteRenderConnection", renderConnection);
                editor.set("_autocompleteModels", autocompleteModels);
                editor.$["autocompletePopup"].open(position[0], position[1]);
                editor.$["autocomplete"].focus();
            });
            // TODO: dude-popup should handle this
            this.addOwnKeyBinding("esc", "_closeAutocomplete");
        },

        /**
         *
         * @param {Object} graphData
         * @param {Object} rendererData
         */
        load: function (graphData, rendererData) {
            this.get("loader").load(this.get("graph"), graphData);
            this.get("renderer").load(rendererData);
        },

        /**
         *
         * @returns {Object}
         */
        saveGraphData: function () {
            return this.get("saver").save(this.get("graph"));
        },

        /**
         *
         * @returns {Object}
         */
        saveRendererData: function () {
            return this.get("renderer").save();
        },

        /**
         *
         * @returns {Object}
         */
        save: function () {
            return {
                "graphData": this.saveGraphData(),
                "rendererData": this.saveRendererData()
            }
        },

        /**
         *
         * @param {Object} blockData
         * @returns {dudeGraph.RenderBlock}
         */
        createBlock: function (blockData) {
            var cgBlock = this.get("loader").loadBlock(this.get("graph"), _.merge(blockData, {
                "cgId": _.uuid()
            }));
            return this.renderer.createRenderBlock({
                "id": cgBlock.cgId,
                "cgBlock": cgBlock.cgId
            }, true);
        },

        /**
         *
         * @param type
         * @param isOutput
         */
        queryModels: function (type, isOutput) {
            var modelsFound = [];
            (function recursiveQueryModels(models) {
                _.forEach(models, function (model) {
                    if (!_.isUndefined(model.item)) {
                        var cgLookupPoints = isOutput ? model.item.data.cgInputs : model.item.data.cgOutputs;
                        var found = _.find(cgLookupPoints, function (point) {
                            return point.cgType === type || point.cgValueType === type;
                        });
                        if (found) {
                            modelsFound.push(model);
                        }
                    } else if (!_.isUndefined(model.group)) {
                        recursiveQueryModels(model.group.items);
                    }

                });
            })(this.get("models"));
            return modelsFound;
        },

        /**
         *
         * @param {CustomEvent} e
         * @private
         */
        _autocomplete: function (e) {
            if (e.detail.item.data) {
                var draggingRenderPoint = this._autocompleteRenderConnection.draggingRenderPoint;
                var fromRenderPoint = this._autocompleteRenderConnection.realRenderPoint;
                var fromRenderBlock = fromRenderPoint.renderBlock;
                var toRenderBlock = this.createBlock(e.detail.item.data);
                var toRenderPoint = _.find(toRenderBlock.renderPoints, function (renderPoint) {
                            // Tries to find the best suitable point
                            return renderPoint.point.isOutput !== fromRenderPoint.point.isOutput &&
                                    renderPoint.point.cgValueType === fromRenderPoint.point.cgValueType;
                        }) || null;
                if (toRenderPoint === null) {
                    throw new Error("Cannot find suitable point for `" + fromRenderPoint.pointFancyName +
                            "` in `" + toRenderBlock.nodeFancyName + "`");
                }
                // TODO: Move the block at the mouse position
                toRenderBlock.nodePosition = _.clone(draggingRenderPoint.pointAbsolutePosition);
                toRenderBlock.update();
                var connection = fromRenderPoint.point.connect(toRenderPoint.point);
                this.get("renderer").createRenderConnection({
                    connection: connection,
                    outputRenderBlock: fromRenderPoint.point.isOutput ? fromRenderBlock : toRenderBlock,
                    inputRenderBlock: fromRenderPoint.point.isOutput ? toRenderBlock : fromRenderBlock
                }, true);
                this.get("renderer").clearSelection();
                this.get("renderer").addToSelection([toRenderBlock]);
                this.get("renderer").panToFitRenderNodes([toRenderBlock]);
            }
            this.$["autocompletePopup"].close();
        },

        /**
         *
         * @private
         */
        _closeAutocomplete: function () {
            this.$["autocompletePopup"].close();
        }
    });

    var defaultBlockTypes = [
        {"block": "Assignation", "type": dudeGraph.Assignation},
        {"block": "Condition", "type": dudeGraph.Condition},
        {"block": "Delegate", "type": dudeGraph.Delegate},
        {"block": "Each", "type": dudeGraph.Each},
        {"block": "Function", "type": dudeGraph.Function},
        {"block": "Getter", "type": dudeGraph.Getter},
        {"block": "Instruction", "type": dudeGraph.Instruction},
        {"block": "Operator", "type": dudeGraph.Operator},
        {"block": "Range", "type": dudeGraph.Range},
        {"block": "Variable", "type": dudeGraph.Variable}
    ];
    var defaultPointTypes = [
        {"point": "Choice", "type": dudeGraph.Choice},
        {"point": "Stream", "type": dudeGraph.Stream}
    ];
    var defaultRenderBlockTypes = [
        {"renderBlock": "Assignation", "type": dudeGraph.RenderBlock},
        {"renderBlock": "Condition", "type": dudeGraph.RenderBlock},
        {"renderBlock": "Delegate", "type": dudeGraph.RenderBlock},
        {"renderBlock": "Each", "type": dudeGraph.RenderBlock},
        {"renderBlock": "Function", "type": dudeGraph.RenderBlock},
        {"renderBlock": "Getter", "type": dudeGraph.RenderBlock},
        {"renderBlock": "Instruction", "type": dudeGraph.RenderBlock},
        {"renderBlock": "Operator", "type": dudeGraph.RenderBlock},
        {"renderBlock": "Range", "type": dudeGraph.RenderBlock},
        {"renderBlock": "Variable", "type": dudeGraph.RenderVariable}
    ];
</script>