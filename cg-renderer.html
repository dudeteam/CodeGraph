<!--
    It's the most important polymer component of CodeGraph. It creates the SVG from JSON data and provide an API to add,
    remove or select data of this graph.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-ajax/core-ajax.html">
<polymer-element name="cg-renderer">
    <template>
        <style>
            #svg {
                overflow: hidden;
            }
            #svg #selection {
                fill: rgba(255, 255, 255, 0.2);
                stroke: rgba(255, 255, 255, 0.5);
                stroke-width: 1px;
            }
            #svg .group, #svg .block {
                cursor: move;
            }
            #svg .action .title {
                text-anchor: middle;
            }
            #svg .input, #svg .output {
                cursor: pointer;
            }
            .connection {
                stroke-linecap: round;
            }
        </style>
        <div id="shadow-dom-bug" layout horizontal flex>
            <svg id="svg" flex></svg>
        </div>
    </template>
    <!-- Vendors -->
    <script src="../d3/d3.js"></script>
    <script src="../jwerty/jwerty.js"></script>
    <script src="../pandora/lib/pandora.js"></script>
    <!-- CodeGraph library -->
    <script src="codegraph.js"></script>
    <!-- Polymer element -->
    <script>
        Polymer({
            publish: {

                /**
                 * JSON data to create the graph.
                 * @type {Object}
                 */
                graph: null,

                /**
                 * Some configuration settings for the graph rendering.
                 * @type {Object}
                 */
                config: {}

            },
            _isReady: false,
            get isReady() { return this._isReady; },

            handleErrors: function () {
                this._loader.on("error", function (error) { this.fire("error", {error: error}); }.bind(this));
                this._saver.on("error", function (error) { this.fire("error", {error: error}); }.bind(this));
                this._graph.on("error", function (error) { this.fire("error", {error: error}); }.bind(this));
                this._renderer.on("error", function (error) { this.fire("error", {error: error}); }.bind(this));
            },

            createVariable: function (type, name, value) {
                if (name === "") {
                    this.fire("error", {error: new pandora.Exception("A name should provided to create a variable")});
                    return false;
                }
                if (this._graph.getModel(name) !== undefined) {
                    this.fire("error", {error: new pandora.Exception("Variable {0} already exists", name)});
                    return false;
                }
                this._graph.addModel(new cg.Variable({
                    "name": name,
                    "value-type": type,
                    "value": value
                }));
                return true;
            },

            editVariable: function (previous, type, name, value) {
                if (name === "") {
                    this.fire("error", {error: new pandora.Exception("A name should provided to create a variable")});
                    return false;
                }
                if (name !== previous && this._graph.getModel(name) !== undefined) {
                    this.fire("error", {error: new pandora.Exception("Variable {0} already exists", name)});
                    return false;
                }
                this._graph.deleteModel(name);
                this._graph.addModel(new cg.Variable({
                    "name": name,
                    "value-type": type,
                    "value": value
                }));
                return true;
            },

            deleteVariable: function (name) {
                this._graph.deleteModel(name);
            },

            createGroup: function (name) {
                var _id = graph.getNextGroupId();
                this._renderer.createSmartGroup(_id, name);
            },

            createAction: function (model, position) {
                var block = new cg.Block(this._graph.getNextBlockId(), model, position);
                this._graph.addEntity(block, this._graph);
                return block;
            },

            createPicker: function (pattern, searchResult, position, parent) {
                var model = this._getValueModel(pattern) || this._getVariableModel(searchResult);
                if (model === null) {
                    return null;
                }
                var block = new cg.Block(this._graph.getNextBlockId(), model, position);
                this._graph.addEntity(block, parent || this._graph);
                return block;
            },

            replacePicker: function (pattern, searchResult, entity) {
                var block = this.createPicker(pattern, searchResult, entity.position, entity.parent);
                if (block !== null) {
                    pandora.forEach(entity.outputs[0].connections, function (connection) {
                        this._graph.addConnection(new cg.Connection(block.outputs[0], connection.inputPoint));
                    }.bind(this));
                    this._graph.removeEntity(entity);
                }
                return block;
            },

            _getValueModel: function (pattern) {
                if (/^(true|false)$/.test(pattern)) {
                    return new cg.Value({
                        "value-type": "boolean",
                        "default": pattern === "true"
                    });
                } else if (/^".+"$/.test(pattern)) {
                    return new cg.Value({
                        "value-type": "string",
                        "default": pattern.substr(1, pattern.length - 2)
                    });
                } else if (/^[0-9]+$/.test(pattern)) {
                    return new cg.Value({
                        "value-type": "number",
                        "default": parseInt(pattern)
                    });
                } else if (/^[a-zA-Z0-9\/]+\.mp3$/.test(pattern)) {
                    return new cg.Value({
                        "value-type": "sound",
                        "default": pattern
                    });
                }
                return null;
            },

            _getVariableModel: function (searchResult) {
                if (searchResult.length > 0) {
                    return new cg.Variable({
                        "value-type": searchResult[0].data.valueType,
                        "name": searchResult[0].name
                    });
                }
                return null;
            },

            removeSelection: function () {
                this._renderer.removeSelection();
            },

            hasSelectedEntities: function () {
                return this._renderer.hasSelectedEntities();
            },

            hasSelection: function () {
                return this._renderer.hasSelection();
            },

            zoomToFit: function () {
                this._renderer.zoomToFit();
            },

            findModels: function (options) {
                return this._graph.findModels(options);
            },

            getLastSelectedEntity: function() {
                return this._renderer.getLastSelectedEntity();
            },

            toJSON: function () {
                return this._saver.save(this._graph);
            },

            graphChanged: function () {
                this.$.svg.innerHTML = "";
                this._graph = new cg.Graph();
                this._loader = new cg.JSONLoader();
                this._saver = new cg.JSONSaver();
                this._renderer = new cg.Renderer(this._graph, this.$.svg, this.config);
                this.handleErrors();
                this._renderer.on("picker.edit", function (picker) {
                    this.fire("picker.edit", {picker: picker});
                }.bind(this));
                this._loader.load(this._graph, this.graph);
                this._renderer.render();
                this._isReady = true;
                this.fire("ready");

                // FOR DEBUG

                window.cgGraph = this._graph;
                window.cgRenderer = this._renderer;
                window.cgLoader = this._loader;
                window.cgSaver = this._saver;

            }
        });
    </script>
</polymer-element>