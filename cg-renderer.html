<!--
    It's the most important polymer component of CodeGraph. It creates the SVG from JSON data and provide an API to add,
    remove or select data of this graph.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-ajax/core-ajax.html">
<polymer-element name="cg-renderer">
    <template>
        <style>
            #svg {
                overflow: hidden;
            }
            #svg #selection {
                fill: rgba(255, 255, 255, 0.2);
                stroke: rgba(255, 255, 255, 0.5);
                stroke-width: 1px;
            }
            #svg .group, #svg .block {
                cursor: move;
            }
            #svg .action .title {
                text-anchor: middle;
            }
            #svg .input, #svg .output {
                cursor: pointer;
            }
            .connection {
                stroke-linecap: round;
            }
        </style>
        <div id="shadow-dom-bug" layout horizontal flex>
            <svg id="svg" flex></svg>
        </div>
    </template>
    <!-- Vendors -->
    <script src="../d3/d3.js"></script>
    <script src="../jwerty/jwerty.js"></script>
    <script src="../pandora/lib/pandora.js"></script>
    <!-- CodeGraph library -->
    <script src="codegraph.js"></script>
    <!-- Polymer element -->
    <script>
        Polymer({
            publish: {

                /**
                 * This is the url of the graph data to load.
                 * @attribute graphData Json data representing the graph to render
                 * @type {Object}
                 */
                graphData: null

            },
            _isReady: false,
            get isReady() { return this._isReady; },

            handleErrors: function () {
                this.loader.on("error", function (error) { this.fire("error", {error: error}); }.bind(this));
                this.saver.on("error", function (error) { this.fire("error", {error: error}); }.bind(this));
                this.graph.on("error", function (error) { this.fire("error", {error: error}); }.bind(this));
                this.renderer.on("error", function (error) { this.fire("error", {error: error}); }.bind(this));
            },

            createVariable: function (type, name) {
                this.graph.addModel(new cg.Variable({
                    "name": name,
                    "value-type": type
                }));
            },

            createGroup: function (name) {
                var _id = graph.getNextGroupId();
                this.renderer.createSmartGroup(_id, name);
            },

            createAction: function (model, position) {
                var block = new cg.Block(this.graph.getNextBlockId(), model, position);
                this.graph.addEntity(block, this.graph);
                return block;
            },

            createPicker: function (pattern, searchResult, position, parent) {
                var model = this._getValueModel(pattern) || this._getVariableModel(searchResult);
                if (model === null) {
                    return null;
                }
                var block = new cg.Block(this.graph.getNextBlockId(), model, position);
                this.graph.addEntity(block, parent || this.graph);
                return block;
            },

            replacePicker: function (pattern, searchResult, entity) {
                var block = this.createPicker(pattern, searchResult, entity.position, entity.parent);
                if (block !== null) {
                    pandora.forEach(entity.outputs[0].connections, function (connection) {
                        this.graph.addConnection(new cg.Connection(block.outputs[0], connection.inputPoint));
                    }.bind(this));
                    this.graph.removeEntity(entity);
                }
                return block;
            },

            _getValueModel: function (pattern) {
                if (/^(true|false)$/.test(pattern)) {
                    return new cg.Value({
                        "value-type": "boolean",
                        "default": pattern === "true"
                    });
                } else if (/^".+"$/.test(pattern)) {
                    return new cg.Value({
                        "value-type": "string",
                        "default": pattern.substr(1, pattern.length - 2)
                    });
                } else if (/^[0-9]+$/.test(pattern)) {
                    return new cg.Value({
                        "value-type": "number",
                        "default": parseInt(pattern)
                    });
                } else if (/^[a-zA-Z0-9\/]+\.mp3$/.test(pattern)) {
                    return new cg.Value({
                        "value-type": "sound",
                        "default": pattern
                    });
                }
                return null;
            },

            _getVariableModel: function (searchResult) {
                if (searchResult.length > 0) {
                    return new cg.Variable({
                        "value-type": searchResult[0].data.valueType,
                        "name": searchResult[0].name
                    });
                }
                return null;
            },

            removeSelection: function () {
                this.renderer.removeSelection();
            },

            hasSelectedEntities: function () {
                return this.renderer.hasSelectedEntities();
            },

            hasSelection: function () {
                return this.renderer.hasSelection();
            },

            zoomToFit: function () {
                this.renderer.zoomToFit();
            },

            findModels: function (options) {
                return this.graph.findModels(options);
            },

            getLastSelectedEntity: function() {
                return this.renderer.getLastSelectedEntity();
            },

            toJSON: function () {
                return this.saver.save(this.graph);
            },

            graphDataChanged: function () {
                this.config = {};
                this.$.svg.innerHTML = "";
                this.graph = new cg.Graph();
                this.loader = new cg.JSONLoader();
                this.saver = new cg.JSONSaver();
                this.renderer = new cg.Renderer(this.graph, this.$.svg, this.config);
                window.graph = this.graph;
                window.renderer = this.renderer;
                window.loader = this.loader;
                window.saver = this.saver;
                this.handleErrors();
                this.renderer.on("picker.edit", function (picker) {
                    this.fire("picker.edit", {picker: picker});
                }.bind(this));
                this.loader.load(this.graph, this.graphData);
                this.renderer.render();
                this._isReady = true;
                this.fire("ready");
            }
        });
    </script>
</polymer-element>