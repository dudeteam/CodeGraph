<!--
    It's the most important polymer component of CodeGraph. It creates the SVG from JSON data and provide an API to add,
    remove or select data of this graph.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-ajax/core-ajax.html">
<polymer-element name="cg-renderer">
    <template>
        <style>
            #svg {
                overflow: hidden;
            }
            #svg #selection {
                fill: rgba(255, 255, 255, 0.2);
                stroke: rgba(255, 255, 255, 0.5);
                stroke-width: 1px;
            }
            #svg .group, #svg .block {
                cursor: move;
            }
            #svg .action .title {
                text-anchor: middle;
            }
            #svg .input, #svg .output {
                cursor: pointer;
            }
            .connection {
                stroke-linecap: round;
            }
        </style>
        <div id="shadow-dom-bug" layout horizontal flex>
            <svg id="svg" flex></svg>
        </div>
    </template>
    <!-- Vendors -->
    <script src="../d3/d3.js"></script>
    <script src="../jwerty/jwerty.js"></script>
    <script src="../pandora/lib/pandora.js"></script>
    <!-- CodeGraph library -->
    <script src="codegraph.js"></script>
    <!-- Polymer element -->
    <script>
        Polymer({
            publish: {

                /**
                 * JSON data to create the graph.
                 * @type {Object}
                 */
                graph: null,

                /**
                 * Some configuration settings for the graph rendering.
                 * @type {Object}
                 */
                config: {}

            },
            _isReady: false,
            get isReady() { return this._isReady; },

            handleErrors: function () {
                this._loader.on("error", function (error) { this.fire("error", {error: error}); }.bind(this));
                this._graph.on("error", function (error) { this.fire("error", {error: error}); }.bind(this));
                this._renderer.on("error", function (error) { this.fire("error", {error: error}); }.bind(this));
            },

            createVariable: function (type, name, value) {
                if (!name) {
                    this.fire("error", {error: new pandora.Exception("A name should be provided to create a variable")});
                    return false;
                }
                if (/^[_a-zA-Z][a-zA-Z0-9-_'\. ]*$/.test(name) === false) {
                    this.fire("error", {error: new pandora.Exception("A variable name begins with a letter followed by alphanumeric characters, '_',  '-' or spaces")});
                    return false;
                }
                if (this._graph.getModel(name)) {
                    this.fire("error", {error: new pandora.Exception("Variable {0} already exists", name)});
                    return false;
                }
                this._graph.addModel(new cg.Variable({
                    "name": name,
                    "value-type": type,
                    "value": value
                }));
                return true;
            },

            editVariable: function (previous, type, name, value) {
                if (!name) {
                    this.fire("error", {error: new pandora.Exception("A name should be provided to create a variable")});
                    return false;
                }
                if (/^[_a-zA-Z][a-zA-Z0-9-_'\. ]*$/.test(name) === false) {
                    this.fire("error", {error: new pandora.Exception("A variable name begins with a letter followed by alphanumeric characters, '_',  '-' or spaces")});
                    return false;
                }
                if (previous !== name && this._graph.getModel(name)) {
                    this.fire("error", {error: new pandora.Exception("Variable {0} already exists", name)});
                    return false;
                }
                var model = this._graph.getModel(previous);
                if (!model) {
                    this.fire("error", {error: new pandora.Exception("Variable {0} does not exist", previous)});
                    return false;
                }
                var blocks = this._graph.findBlocks(function (block) {
                    return block._name === previous;
                });
                model._name = name;
                model.value = value;
                pandora.forEach(blocks, function (block) {
                    block.__name = name;
                    block.emit("update");
                    block.emit("move");
                });
                return true;
            },

            deleteVariable: function (name) {
                var blocks = this._graph.findBlocks(function (block) {
                    return block._name === name;
                });
                pandora.forEach(blocks, function (block) {
                    this._graph.removeEntity(block);
                }.bind(this));
                this._graph.removeModel(name);
            },

            createGroup: function (name) {
                var _id = this._graph.getNextGroupId();
                this._renderer.createSmartGroup(_id, name);
            },

            createAction: function (model, position) {
                position.assign([
                    (position.x - this._graph.zoom.translate[0]) / this._graph.zoom.scale,
                    (position.y - this._graph.zoom.translate[1]) / this._graph.zoom.scale
                ]);
                var block = new cg.Block(this._graph.getNextBlockId(), model, position);
                this._graph.addEntity(block, this._graph);
                return block;
            },

            createProperty: function (pattern, searchResult, position, parent) {
                position.assign([
                    (position.x - this._graph.zoom.translate[0]) / this._graph.zoom.scale,
                    (position.y - this._graph.zoom.translate[1]) / this._graph.zoom.scale
                ]);
                var model = this._getValueModel(pattern) || this._getVariableModel(searchResult);
                if (model === null) {
                    return null;
                }
                var block = new cg.Block(this._graph.getNextBlockId(), model, position);
                this._graph.addEntity(block, parent || this._graph);
                return block;
            },

            replaceProperty: function (pattern, searchResult, entity) {
                var block = this.createProperty(pattern, searchResult, entity.position, entity.parent);
                if (block !== null) {
                    var connection = entity.outputs[0].connections[0] || null;
                    this._graph.removeEntity(entity);
                    if (connection !== null) {
                        this._graph.addConnection(new cg.Connection(block.outputs[0], connection.inputPoint));
                    }
                }
                return block;
            },

            _getValueModel: function (pattern) {
                if (/^(true|false)$/.test(pattern)) {
                    return new cg.Value({
                        "value-type": "boolean",
                        "value": pattern === "true"
                    });
                } else if (/^".*"$/.test(pattern)) {
                    return new cg.Value({
                        "value-type": "string",
                        "value": pattern.substr(1, pattern.length - 2)
                    });
                } else if (/^[0-9]+$/.test(pattern)) {
                    return new cg.Value({
                        "value-type": "number",
                        "value": parseInt(pattern)
                    });
                }
                return null;
            },

            _getVariableModel: function (searchResult) {
                return new cg.Variable({
                    "value-type": searchResult.data.valueType,
                    "name": searchResult.name
                });
            },

            removeSelection: function () {
                this._renderer.removeSelection();
            },

            hasSelectedEntities: function () {
                return this._isReady && this._renderer.hasSelectedEntities();
            },

            hasSelection: function () {
                return this._isReady && this._renderer.hasSelection();
            },

            zoomToFit: function () {
                this._renderer.zoomToFit();
            },

            findModels: function (options) {
                return this._graph.findModels(options);
            },

            getLastSelectedEntity: function() {
                return this._renderer.getLastSelectedEntity();
            },

            save: function (saver) {
                saver.on("error", function (error) { this.fire("error", {error: error})}.bind(this));
                return saver.save(this._graph);
            },

            graphChanged: function () {
                this.$.svg.innerHTML = "";
                this._graph = new cg.Graph();
                this._loader = new cg.JSONLoader();
                this._renderer = new cg.Renderer(this._graph, this.$.svg, this.config);
                this.handleErrors();
                this._renderer.on("property.edit", function (property) {
                    this.fire("property.edit", {property: property});
                }.bind(this));
                this._loader.load(this._graph, this.graph);
                this._renderer.render();
                this._isReady = true;
                this.fire("ready");

            }
        });
    </script>
</polymer-element>