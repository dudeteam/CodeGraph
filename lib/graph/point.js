cg.Point = (function () {

    /**
     * A point represents either an input or an output in a block, it has a name and a value type
     * A point can also have one or many references to other points:
     *    - The outbound point must be an output
     *    - The outbound point value type must be accepted by the inbound point
     *    - The outbound point must have a back reference to this point
     * Example for an input point:
     * {
     *      "cgBlock": "1", // The unique identifier to the block, required
     *      "cgName": "sum a", // The block input name, required
     *      "cgValueType": "Number", // The point value type, required
     *      "cgValue": 32 // The point value for an input, not required
     * }
     * Example for an output point:
     * {
     *      "cgBlock": "1", // The unique identifier to the block, required
     *      "cgName": "result", // The block output name, required
     *      "cgValueType": "Number", // The point value type, required
     *      // For an output, "cgValue" should be generated by the block and read only
     * }
     * @param {cg.Block} cgBlock - The block this point refers to
     * @param {Object} data
     * @param {Boolean} isOutput - True if this point is an output, False for an input
     * @constructor
     */
    var Point = pandora.class_("Point", function (cgBlock, data, isOutput) {
        /**
         * The graph of the block
         * @type {cg.Graph}
         * @private
         */
        this._cgGraph = cgBlock.cgGraph;
        Object.defineProperty(this, "cgGraph", {
            get: function () {
                return this._cgGraph;
            }.bind(this)
        });

        /**
         * The block it belongs to
         * @type {cg.Block}
         * @private
         */
        this._cgBlock = cgBlock;
        Object.defineProperty(this, "cgBlock", {
            get: function () {
                return this._cgBlock;
            }.bind(this)
        });

        /**
         * The block input/output name
         * @private
         */
        this._cgName = data.cgName || pandora.typename(this);
        Object.defineProperty(this, "cgName", {
            get: function () {
                return this._cgName;
            }.bind(this)
        });

        /**
         * Point type, True if this point is an output, False for an input
         * @type {Boolean}
         * @private
         */
        this._isOutput = isOutput;
        Object.defineProperty(this, "isOutput", {
            get: function () {
                return this._isOutput;
            }.bind(this)
        });

        /**
         * Connections from/to this point
         * @type {Array<cg.Connection>}
         * @private
         */
        this._cgConnections = [];
        Object.defineProperty(this, "cgConnections", {
            get: function () {
                return this._cgConnections;
            }.bind(this)
        });

        /**
         * The maximum number of connections this point can accept
         * [0; Infinity] number of connections
         * @type {Number}
         * @private
         */
        this._cgMaxConnections = data.cgMaxConnections || 1;
        Object.defineProperty(this, "cgMaxConnections", {
            get: function () {
                return this._cgMaxConnections;
            }.bind(this),
            set: function (cgMaxConnections) {
                if (!(cgMaxConnections instanceof Number) || cgMaxConnections < 0) {
                    throw new Error("cgMaxConnections must be a zero or positive number");
                }
                this._cgMaxConnections = cgMaxConnections;
            }.bind(this)
        });

        /**
         * The name of the template type used (from parent block).
         * @type {String|null}
         * @private
         */
        this._cgTemplate = data.cgTemplate || null;
        Object.defineProperty(this, "cgTemplate", {
            get: function () {
                return this._cgTemplate;
            }.bind(this)
        });

        /**
         * The point current value type
         * Example: Number (Yellow color)
         * @type {String}
         * @emit "cg-point-value-type-change" {cg.Point} {Object} {Object}
         * @private
         */
        this._cgValueType = data.cgValueType;
        Object.defineProperty(this, "cgValueType", {
            get: function () {
                return this._cgValueType;
            }.bind(this),
            set: function (cgValueType) {
                var old = this._cgValueType;
                this._cgValueType = cgValueType;
                this._cgGraph.emit("cg-point-value-type-change", this, old, cgValueType);
            }.bind(this)
        });
        if (data.cgValueType === undefined) {
            throw new Error("Cannot create the point `" + this._cgName + "` in block `" + this._cgBlock.cgId +
                "` without specifying a value type");
        }

        /**
         * The point current value
         * @type {Object|null}
         * @emit "cg-point-value-change" {cg.Point} {Object} {Object}
         * @private
         */
        this._cgValue = data.cgValue || null;
        Object.defineProperty(this, "cgValue", {
            configurable: true,
            get: function () {
                return this._cgValue;
            }.bind(this),
            set: function (cgValue) {
                if (this._cgConnections.length >= this._cgMaxConnections) {
                    throw new Error("Cannot set `cgValue`: Point `" + this._cgName + "` cannot accept more than `" +
                        this._cgMaxConnections + "` connection(s)");
                }
                if (this._cgGraph.canAssign(cgValue, this._cgValueType)) {
                    var oldCgValue = this._cgValue;
                    this._cgValue = cgValue;
                    this._cgGraph.emit("cg-point-value-change", this, oldCgValue, cgValue);
                } else {
                    throw new Error("Invalid value `" + String(cgValue) +
                        "` for `" + this._cgValueType + "` in `" + this._cgName + "`");
                }
            }.bind(this)
        });
        if (data.cgValue !== undefined && isOutput) {
            throw new Error("Shouldn't create output point `" + this._cgName + "` in block `" +
                this._cgBlock.cgId + "` with a value.");
        }
    });

    /**
     * Returns whether this cgPoint is empty (no connections and no cgValue)
     * @returns {Boolean}
     */
    Point.prototype.empty = function () {
        return this._cgConnections.length === 0 && this._cgValue === null;
    };

    /**
     * Checks if this cgPoint accepts a connection to the given cgPoint
     * @param {cg.Point} cgPoint
     * @returns {Boolean}
     */
    Point.prototype.acceptConnect = function (cgPoint) {
        if (this._cgConnections.length + (this._cgValue === null ? 0 : 1) >= this._cgMaxConnections) {
            throw new Error("Point `" + this._cgName + "` cannot accept more than `" +
                    this._cgMaxConnections + "` connection(s)");
        }
        return true;
    };

    /**
     * Adds a connection from this cgPoint to the given cgPoint
     * @param {cg.Point} cgPoint
     * @return {cg.Connection}
     */
    Point.prototype.connect = function (cgPoint) {
        if (this._isOutput) {
            return this._cgGraph._connectPoints(this, cgPoint);
        } else {
            return this._cgGraph._connectPoints(cgPoint, this);
        }
    };

    /**
     * Removes the connections between this cgPoint and the given cgPoint
     * @param {cg.Point} cgPoint
     */
    Point.prototype.disconnect = function (cgPoint) {
        if (this._isOutput) {
            return this._cgGraph._disconnectPoints(this, cgPoint);
        } else {
            return this._cgGraph._disconnectPoints(cgPoint, this);
        }
    };

    /**
     * Returns a copy of this point
     * @param {cg.Block} cgBlock - The block on which this cloned point will be attached to
     * @return {cg.Point}
     */
    Point.prototype.clone = function (cgBlock) {
        if (pandora.typename(this) !== "Point") {
            throw new Error("Point::clone() method must be overridden by `" + pandora.typename(this) + "`");
        }
        return new cg.Point(cgBlock, {
            cgName: this._cgName,
            cgValueType: this._cgValueType,
            cgValue: this._cgValue
        }, this._isOutput);
    };

    return Point;

})();