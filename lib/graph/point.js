cg.Point = (function () {

    /**
     * A point represents either an input or an output in a block, it has a name and a value type
     * A point can also have one or many references to other points:
     *    - The outbound point must be an output
     *    - The outbound point value type must be accepted by the inbound point
     *    - The outbound point must have a back reference to this point
     * Example for an input point:
     * {
     *      "cgBlock": "1", // The unique identifier to the block, required
     *      "cgName": "sum a", // The block input name, required
     *      "cgValueType": "Number", // The point value type, required
     *      "cgValue": 32 // The point value for an input, not required
     * }
     * Example for an output point:
     * {
     *      "cgBlock": "1", // The unique identifier to the block, required
     *      "cgName": "result", // The block output name, required
     *      "cgValueType": "Number", // The point value type, required
     *      // For an output, "cgValue" should be generated by the block and read only
     * }
     * @param cgBlock {cg.Block} The block this point refers to
     * @param cgPointName {String} The block point name for the input or output
     * @param isOutput {Boolean} True if this point is an output, False for an input
     * @extends {pandora.EventEmitter}
     * @constructor
     */
    var Point = pandora.class_("Point", pandora.EventEmitter, function (cgBlock, cgPointName, isOutput) {
        pandora.EventEmitter.call(this);

        /**
         * The graph of the block
         * @type {cg.Graph}
         * @private
         */
        this._cgGraph = cgBlock.cgGraph;

        /**
         * The block it belongs to
         * @type {cg.Block}
         * @private
         */
        this._cgBlock = cgBlock;
        Object.defineProperty(this, "cgBlock", {
            get: function () {
                return this._cgBlock;
            }.bind(this)
        });

        /**
         * Point type, True if this point is an output, False for an input
         * @type {Boolean}
         * @private
         */
        this._isOutput = isOutput;
        Object.defineProperty(this, "isOutput", {
           get: function() {
               return this._isOutput;
           }.bind(this)
        });

        /**
         * The block input/output name
         * @private
         */
        this._cgName = cgPointName;
        Object.defineProperty(this, "cgName", {
            get: function () {
                return this._cgName;
            }.bind(this)
        });

        /**
         * Connections from/to this point
         * @type {Array<cg.Connection>}
         * @private
         */
        this._cgConnections = [];
        Object.defineProperty(this, "cgConnections", {
            get: function () {
                return this._cgConnections;
            }.bind(this)
        });

        /**
         * The point current value type
         * Example: Number (Yellow color)
         * @type {String}
         * @private
         */
        this._cgValueType = undefined;
        Object.defineProperty(this, "cgValueType", {
            get: function () {
                return this._cgValueType;
            }.bind(this),
            set: function(cgValueType) {
                if (this._cgValueTypesAllowed.indexOf(cgValueType) === -1) {
                    throw cg.GraphError("Point::cgValueType() Cannot change cgValueType to a non allowed type `{0}`", cgValueType);
                }
                if (this._cgConnections.length > 0) {
                    // TODO: Check connections if valueType really changes
                    // TODO: Handle type conversion
                    throw cg.GraphError("Point::cgValueType() Cannot change cgValueType if connections are bound to this point `{0}`", cgValueType);
                }
                var oldCgValueType = this._cgValueType;
                this._cgValueType = cgValueType;
                // TODO: Graph emit
                this.emit('value-type-changed', oldCgValueType, cgValueType);
            }.bind(this)
        });

        /**
         * The point current value
         * @type {Object|null}
         * @private
         */
        this._cgValue = null;
        Object.defineProperty(this, "cgValue", {
            get: function () {
                return this._cgValue;
            }.bind(this),
            set: function(cgValue) {
                this.cgValueType = pandora.typename(cgValue);
                var oldCgValue = this._cgValue;
                this._cgValue = cgValue;
                // TODO: Graph emit
                this.emit('value-changed', oldCgValue, cgValue);
            }.bind(this)
        });

        /**
         * The types this point can accept
         * @type {Array<String>}
         * @private
         */
        this._cgValueTypesAllowed = ["Number", "Boolean", "String"];

    });

    /**
     * Adds a connection from this inbound point to an outbound point
     * @param {cg.Point} cgPoint
     * @return {cg.Connection}
     */
    Point.prototype.connect = function(cgPoint) {
        if (this._isOutput === cgPoint.isOutput) {
            throw new cg.GraphError("Point::addConnection() Cannot connect either two inputs or two outputs: `{0}` and `{1}`", this._cgName, cgPoint.cgName);
        }
        if (this._isOutput) {
            this._cgGraph.connectPoints(this, cgPoint);
        } else {
            this._cgGraph.connectPoints(cgPoint, this);
        }
    };

    return Point;

})();